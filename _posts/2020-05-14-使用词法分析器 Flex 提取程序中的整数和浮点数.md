---
redirect_from: /_posts/2020-05-14-%E4%BD%BF%E7%94%A8%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-Flex-%E6%8F%90%E5%8F%96%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/
title: 使用词法分析器 Flex 提取程序中的整数和浮点数
tags: 编译原理
---

![成绩]

Flex 是一个生成词法分析器的工具，它可以利用正则表达式来生成匹配相应字符串的 C 语言代码，其语法格式基本同 Lex 相同。本文基于 Flex 实现下面的功能：

输入一个合法的 C/C++ 程序，提取程序中的整数和浮点数，并统计各自出现的次数。注意像变量名或函数名中包含的数字不应统计进去。实验加分项：忽略掉注释里面的整数和浮点数。

- [Flex 官方手册](http://westes.github.io/flex/manual/index.html)

## 实验环境

- Windows 10 1909, 64-bit 18363.836
  - Visual Studio Code 1.45.0
    - Remote - WSL 0.44.2：配合 WSL，在 Windows 上获得 Linux 接近原生环境的体验。
  - Windows Subsystem for Linux [Ubuntu 18.04.2 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。
    - gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04.1)
    - flex 2.6.4

词法分析器 Flex 可通过在 WSL 终端上输入如下指令安装。

```bash
sudo apt install -y flex
```

## 实验原理

### 需要跳过的内容

```bash
NEW_LINE \n|\r

COMMENT \/\*([^*]|{NEW_LINE}|(\*+([^*\/]|{NEW_LINE})))*\*+\/

SINGLE_COMMENT \/\/.*

UNICODE \\(u|U)[0-9a-fA-F]+

IDENTIFIER ({UNICODE}|[a-zA-Z_])({UNICODE}|[a-zA-Z_0-9])*
```

1. flex 默认是单行匹配，所以我们要手动跳过 `NEW_LINE`。
2. C 语言的注释分为两种。其中，由 `/*`、`*/` 包裹的部分是多行注释 `COMMENT`，我参考了之前某一次作业中的[小小语言](https://wu-kan.cn/_posts/2020-04-28-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BA%8C/#%E8%AE%BE%E6%9C%89%E4%B8%80%E9%97%A8%E5%B0%8F%E5%B0%8F%E8%AF%AD%E8%A8%80%E4%BB%85%E5%90%AB-zo%E6%96%9C%E6%9D%A03-%E4%B8%AA%E7%AC%A6%E5%8F%B7%E8%AF%A5%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E9%87%8A%E4%BB%A5%E4%B8%80%E4%B8%AAo-%E4%B8%BA%E5%BC%80%E5%A7%8B%E6%A0%87%E8%AE%B0%E4%BB%A5%E6%AD%A4%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-o%E4%B8%BA%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0)。
3. 单行注释 `SINGLE_COMMENT` 匹配的方式相对简单，没有什么可以说的。
4. 标识符 `INDENTIFIER` 参照了 [cppreference.com](https://zh.cppreference.com/w/c/language/identifier) 中的要求。此处考虑了以 `\u`或 `\U` 开始的 Unicode 字符扩展。由于是否在标识符中允许未处理（未转义）的 Unicode 字符没有在 C 语言标准中定义，此处不考虑。

### 整数

```bash
HEX (\+|\-)?0(X|x)[0-9a-fA-F]+
OCTAL (\+|\-)?0[0-7]+
DECIMAL (\+|\-)?[0-9]+

INT {HEX}|{OCTAL}|{DECIMAL}
INTEGER {INT}(u|U)?(l|L|(ll)|(LL))?
```

参照 [cppreference.com](https://zh.cppreference.com/w/c/language/integer_constant) 中的说法，整数常量是拥有下列类型的非左值表达式：

1. decimal-constant integer-suffix(可选)
2. octal-constant integer-suffix(可选)
3. hex-constant integer-suffix(可选)

其中：

- decimal-constant 是非零十进制数位（ 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9 ），跟随零个或更多十进制数字（ 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9）
- octal-constant 是数字零（ 0 ）跟随零个或更多八进制数位（ 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 ）
- hex-constant 是字符序列 0x 或字符序列 0X 跟随一个或更多十六进制数位（ 0 、 1 、 2 、 3、 4、 5 、 6 、 7 、 8 、 9 、 a 、 A 、 b 、 B 、 c 、 C 、 d 、 D、 e 、 E 、 f 、 F ）
- integer-suffix ，若提供则可包含下面一或两者，可以任何顺序出现：
- unsigned-suffix （字符 u 或字符 U ）
- long-suffix （字符 l 或字符 L 或 long-long-suffix （字符序列 ll 或 LL ） (C99 起)

因此匹配的时候要分十六进制、八进制、十进制三种情况考虑（`0B`打头的二进制仅由部分编译器实现，不是 C 语言标准所规定，这里不考虑）。

### 浮点数

```bash
HEX_FLOAT {HEX}(\.[0-9a-fA-F]+)?((P|p){INT})?
DECIMAL_FLOAT {DECIMAL}(\.[0-9]+)?((E|e){INT})?

FLOAT {HEX_FLOAT}|{DECIMAL_FLOAT}(f|F|l|L)?
```

参照 [cppreference.com](https://zh.cppreference.com/w/c/language/floating_constant) 中的说法，浮点常量是非左值表达式，拥有下列形式：

- significand exponent(可选) suffix(可选)

其中 significand 拥有形式

- whole-number(可选) .(可选) fraction(可选)

exponent 拥有形式：

1. 十进制浮点常量的指数语法：e \| E exponent-sign(可选) digit-sequence
2. 十六进制浮点常量的指数语法：p \| P exponent-sign(可选) digit-sequence (C99 起)

因此也要分十六进制和十进制两种情况考虑。要注意的是这里指数部分为 digit-sequence，匹配的是一个数字序列，而非特定的十六进制或者十进制数。

## 实验过程

`flex` 通过读取一个有规定格式的`*.l`文本文件，输出一个 C 语言源程序 `lex.yy.c`，再对其编译可得到可执行文件；其主要流程如下图。

```mermaid
flowchart LR
*.l文件--flex-->lex.yy.c文件--C编译器-->可执行文件
```

### 源代码 `lex.l`

```c
%{
#include <stdio.h>

int cnt_integer = 0, cnt_float = 0;
float \U0001f431 = +31.415926E-1F;
/*
3.14
*/
// 3.14
void __attribute__((destructor)) after_main() {
  fprintf(yyout, "\n---\n%d integer(s), %d float(s) find.\n", cnt_integer,
          cnt_float);
}
%}
%option main yylineno

NEW_LINE \n|\r

COMMENT \/\*([^*]|{NEW_LINE}|(\*+([^*\/]|{NEW_LINE})))*\*+\/

SINGLE_COMMENT \/\/.*

UNICODE \\(u|U)[0-9a-fA-F]+

IDENTIFIER ({UNICODE}|[a-zA-Z_])({UNICODE}|[a-zA-Z_0-9])*

HEX (\+|\-)?0(X|x)[0-9a-fA-F]+
OCTAL (\+|\-)?0[0-7]+
DECIMAL (\+|\-)?[0-9]+

INT {HEX}|{OCTAL}|{DECIMAL}
INTEGER {INT}(u|U)?(l|L|(ll)|(LL))?

HEX_FLOAT {HEX}(\.[0-9a-fA-F]+)?((P|p){INT})?
DECIMAL_FLOAT {DECIMAL}(\.[0-9]+)?((E|e){INT})?

FLOAT {HEX_FLOAT}|{DECIMAL_FLOAT}(f|F|l|L)?

%%

{COMMENT}|{SINGLE_COMMENT}|{IDENTIFIER} {}
{INTEGER} {
  fprintf(yyout, "Line %d, no.%d integer: %s\n", yylineno, ++cnt_integer,
          yytext);
}
{FLOAT} {
  fprintf(yyout, "Line %d, no.%d float: %s\n", yylineno, ++cnt_float,
          yytext);
}
. {}

%%
```

源代码，可以看到，`*.l`格式的输入文件由以下三个部分组成：

1. 由`%{ %}`包裹的 C 语言代码，其中包含第二部分匹配是需要修改的一些变量；然后预定义一些正则匹配规则。此处加一个选项 `%option noyywrap`，表示文件中不会调用 `yywrap()` 函数（假设生成的扫描器只扫描单个文件），这样就不用再实现一个了。
2. 每行一个正则匹配规则，以及匹配成功时「触发」的操作。
3. （可选）剩余的 C 语言代码。需要包含用户自己的 `yywrap` 函数体和 `main` 函数，且 `main` 函数需要调用 `yylex` 函数；也可以使用 `%option main` 自动生成，这个选项暗含了 `%option noyywrap`。

上述几个部分由`%%`间隔。在 C 语言代码中，我构造了一些测试样例：使用 Unicode 扩展的变量名（不应该被识别）、浮点数 `+31.415926E-1F`（该被识别）、两个注释中的浮点数 `3.14` （不该被识别）。

由于我想使用自动生成的 `main` 函数，又想在程序结束的时候输出统计的数量，此处我使用了 [`__attribute__((destructor))`](https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Common-Function-Attributes.html)。

### 生成 `lex.yy.c`

```bash
flex lex.l
```

由于不同版本的 Flex 可能生成出来的结果略有差异，这里我放出我自己生成的 `lex.yy.c`

```c

#line 3 "lex.yy.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
     *       access to the local variable yy_act. Since yyless() is a macro, it would break
     *       existing scanners that call yyless() from OUTSIDE yylex.
     *       One obvious solution it to make yy_act a global. I tried that, and saw
     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
     *       normally declared as a register variable-- so it is not worth it.
     */
    #define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)
    #define YY_LINENO_REWIND_TO(dst) \
            do {\
                const char *p;\
                for ( p = yy_cp-1; p >= (dst); --p)\
                    if ( *p == '\n' )\
                        --yylineno;\
            }while(0)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file  );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define yywrap() (/*CONSTCOND*/1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
static int yy_get_next_buffer ( void );
static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 5
#define YY_END_OF_BUFFER 6
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[61] =
    {   0,
        0,    0,    6,    4,    5,    4,    4,    2,    2,    1,
        4,    2,    2,    0,    1,    0,    2,    0,    3,    2,
        2,    0,    2,    1,    0,    0,    0,    0,    0,    1,
        3,    0,    3,    3,    2,    2,    2,    2,    0,    1,
        0,    0,    1,    3,    0,    0,    0,    1,    1,    3,
        3,    0,    3,    3,    1,    3,    3,    0,    3,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    3,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    1,    6,    7,    8,    9,   10,   10,
       10,   10,   10,   10,   10,   11,   11,    1,    1,    1,
        1,    1,    1,    1,   12,   12,   12,   12,   13,   14,
       15,   15,   15,   15,   15,   16,   15,   15,   15,   17,
       15,   15,   15,   15,   18,   15,   15,   19,   15,   15,
        1,   20,    1,    1,   15,    1,   12,   12,   12,   12,

       21,   22,   15,   15,   15,   15,   15,   23,   15,   15,
       15,   24,   15,   15,   15,   15,   25,   15,   15,   26,
       15,   15,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[27] =
    {   0,
        1,    2,    1,    1,    1,    1,    1,    1,    3,    3,
        3,    3,    3,    3,    4,    4,    4,    4,    4,    4,
        3,    3,    4,    4,    4,    4
    } ;

static const flex_int16_t yy_base[71] =
    {   0,
        0,    0,  118,  231,  231,   18,   26,   28,   46,   97,
       15,    0,    0,   55,    0,   51,   22,   68,  231,   98,
       20,    0,   90,   91,   27,    0,   64,   67,   78,    0,
       78,   74,   93,  111,  231,   94,   85,  128,    0,  145,
       93,  126,  231,   54,    0,    0,  163,  166,    0,  175,
       81,  127,  190,  130,    0,    0,  138,    0,    0,  231,
      214,  218,  222,  103,   90,  226,   87,   73,   72,   45
    } ;

static const flex_int16_t yy_def[71] =
    {   0,
       60,    1,   60,   60,   60,   60,   60,   60,    8,   61,
       60,    8,    9,   62,   63,   60,    9,   60,   60,   60,
       60,   64,   60,   61,   60,   65,   62,   62,   66,   63,
       60,   60,   60,   60,   60,   60,   60,   64,   67,   61,
       62,   62,   60,   34,   68,   69,   60,   40,   40,   68,
       69,   60,   60,   60,   48,   50,   60,   70,   70,    0,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60
    } ;

static const flex_int16_t yy_nxt[258] =
    {   0,
        4,    5,    4,    4,    6,    6,    4,    7,    8,    9,
        9,   10,   10,   10,   10,   10,   10,   10,   10,   11,
       10,   10,   10,   10,   10,   10,   12,   13,   13,   14,
       17,   17,   26,   15,   16,   36,   17,   17,   13,   26,
       18,   19,   37,   20,   39,   21,   22,   59,   18,   19,
       23,   39,   21,   22,   13,   13,   28,   28,   29,   31,
       31,   31,   44,   44,   60,   28,   28,   29,   28,   28,
       29,   60,   32,   32,   51,   50,   33,   34,   34,   42,
       42,   29,   33,   34,   34,   43,   31,   31,   31,   48,
       18,   19,   40,   19,   28,   28,   29,   47,   18,   19,

       19,   44,   44,   34,   47,   38,   19,   35,   19,   35,
       25,   45,   35,   35,   19,   19,   25,   60,   45,   34,
       34,   34,   60,   60,   19,   60,   19,   28,   28,   29,
       60,   60,   19,   19,   46,   53,   54,   54,   54,   54,
       54,   60,   60,   36,   47,   21,   57,   57,   54,   60,
       37,   47,   21,   49,   49,   49,   49,   49,   49,   60,
       60,   60,   60,   60,   25,   49,   49,   52,   52,   60,
       60,   53,   54,   54,   55,   55,   55,   55,   55,   55,
       60,   60,   60,   60,   60,   60,   55,   55,   56,   60,
       19,   60,   60,   60,   60,   60,   56,   19,   57,   57,

       54,   60,   60,   60,   60,   60,   60,   60,   58,   60,
       60,   60,   60,   60,   60,   58,   24,   24,   27,   27,
       27,   27,   30,   60,   30,   30,   41,   41,   41,   41,
        3,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60
    } ;

static const flex_int16_t yy_chk[258] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    6,    6,    6,    7,
       17,   17,   11,    7,    8,   21,    8,    8,    8,   11,
        8,    8,   21,    8,   25,    8,    8,   70,    8,    8,
        8,   25,    8,    8,    9,    9,   14,   14,   14,   16,
       16,   16,   44,   44,    9,   27,   27,   27,   28,   28,
       28,    9,   18,   18,   69,   68,   18,   18,   18,   29,
       29,   29,   32,   32,   32,   29,   31,   31,   31,   67,
       31,   31,   65,   31,   41,   41,   41,   51,   31,   31,

       31,   33,   33,   33,   51,   64,   33,   37,   33,   36,
       24,   33,   23,   20,   33,   33,   10,    3,   33,   34,
       34,   34,    0,    0,   34,    0,   34,   42,   42,   42,
        0,    0,   34,   34,   38,   52,   52,   52,   54,   54,
       54,    0,    0,   38,   38,   38,   57,   57,   57,    0,
       38,   38,   38,   40,   40,   40,   40,   40,   40,    0,
        0,    0,    0,    0,   40,   40,   40,   47,   47,    0,
        0,   47,   47,   47,   48,   48,   48,   48,   48,   48,
        0,    0,    0,    0,    0,    0,   48,   48,   50,    0,
       50,    0,    0,    0,    0,    0,   50,   50,   53,   53,

       53,    0,    0,    0,    0,    0,    0,    0,   53,    0,
        0,    0,    0,    0,    0,   53,   61,   61,   62,   62,
       62,   62,   63,    0,   63,   63,   66,   66,   66,   66,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60
    } ;

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[6] =
    {   0,
1, 0, 0, 0, 0,     };

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "lex.l"
#line 2 "lex.l"
#include <stdio.h>

int cnt_integer = 0, cnt_float = 0;
float \U0001f431 = +31.415926E-1F;
/*
3.14
*/
// 3.14
void __attribute__((destructor)) after_main() {
  fprintf(yyout, "\n---\n%d integer(s), %d float(s) find.\n", cnt_integer,
          cnt_float);
}
#line 554 "lex.yy.c"
#line 555 "lex.yy.c"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals ( void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

			int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT
    
    static void yyunput ( int c, char *buf_ptr  );
    
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{
#line 39 "lex.l"


#line 775 "lex.yy.c"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 61 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 231 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					
    yylineno++;
;
			}

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
/* rule 1 can match eol */
YY_RULE_SETUP
#line 41 "lex.l"
{}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 42 "lex.l"
{
  fprintf(yyout, "Line %d, no.%d integer: %s\n", yylineno, ++cnt_integer,
          yytext);
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 46 "lex.l"
{
  fprintf(yyout, "Line %d, no.%d float: %s\n", yylineno, ++cnt_float,
          yytext);
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 50 "lex.l"
{}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 52 "lex.l"
ECHO;
	YY_BREAK
#line 874 "lex.yy.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2)  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    
	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 61 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	int yy_is_jam;
    	char *yy_cp = (yy_c_buf_p);

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 61 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 60);

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp )
{
	char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return 0;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	if ( c == '\n' )
		
    yylineno++;
;

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	yy_size_t num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr )
{
    
	return yy_scan_bytes( yystr, (int) strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg )
{
			fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
    
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 * 
 */
void yyset_lineno (int  _line_number )
{
    
    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str )
{
        yyin = _in_str ;
}

void yyset_out (FILE *  _out_str )
{
        yyout = _out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  _bdebug )
{
        yy_flex_debug = _bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    /* We do not touch yylineno unless the option is enabled. */
    yylineno =  1;
    
    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{
		
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

int main (void);

int main ()
{

	yylex();

	return 0;
}

#line 52 "lex.l"


```

### 运行结果 `lex.log`

终端输入下述指令，生成可执行文件。

```bash
gcc lex.yy.c -o lex
```

使用 `lex.yy.c` 作为输入（我 提 取 我 自 己），并将运行结果写入 `lex.log`。

```bash
./lex < lex.yy.c > lex.log
```

可以看到我的词法分析器准确提取了输入内容的 1189 个整数和 1 个浮点数。

```bash

Line 1, no.1 integer: 3







Line 1, no.2 integer: 2

Line 1, no.3 integer: 6

Line 1, no.4 integer: 4

Line 1, no.5 integer: 0





















Line 1, no.6 integer: 199901L




Line 3, no.7 integer: 1




















Line 3, no.8 integer: -128



Line 3, no.9 integer: -32767
Line 3, no.10 integer: -1



Line 3, no.11 integer: -2147483647
Line 3, no.12 integer: -1



Line 3, no.13 integer: 127



Line 3, no.14 integer: 32767



Line 3, no.15 integer: 2147483647



Line 3, no.16 integer: 255U



Line 3, no.17 integer: 65535U



Line 3, no.18 integer: 4294967295U




Line 3, no.19 integer: 0












Line 3, no.20 integer: 3







Line 3, no.21 integer: 0






Line 8, no.22 integer: 1
Line 8, no.23 integer: 2


Line 11, no.24 integer: 1
Line 11, no.25 integer: 2



Line 11, no.26 integer: 1



Line 11, no.27 integer: 0






Line 14, no.28 integer: 32768


Line 14, no.29 integer: 16384





Line 15, no.30 integer: 2
















Line 15, no.31 integer: 0

Line 15, no.32 integer: 1

Line 15, no.33 integer: 2









Line 21, no.34 integer: 0




Line 21, no.35 integer: -1



Line 21, no.36 integer: 0














Line 21, no.37 integer: 0



































Line 37, no.38 integer: 0

Line 37, no.39 integer: 1


Line 46, no.40 integer: 2






Line 46, no.41 integer: 0

Line 46, no.42 integer: 0

















Line 53, no.43 integer: 0

Line 53, no.44 integer: 0

















































Line 55, no.45 integer: 1









Line 55, no.46 integer: 1


















Line 57, no.47 integer: 0


Line 57, no.48 integer: 5

Line 57, no.49 integer: 6







Line 58, no.50 integer: 61

Line 58, no.51 integer: 0

Line 58, no.52 integer: 0
Line 58, no.53 integer: 0
Line 58, no.54 integer: 6
Line 58, no.55 integer: 4
Line 58, no.56 integer: 5
Line 58, no.57 integer: 4
Line 58, no.58 integer: 4
Line 58, no.59 integer: 2
Line 58, no.60 integer: 2
Line 58, no.61 integer: 1

Line 58, no.62 integer: 4
Line 58, no.63 integer: 2
Line 58, no.64 integer: 2
Line 58, no.65 integer: 0
Line 58, no.66 integer: 1
Line 58, no.67 integer: 0
Line 58, no.68 integer: 2
Line 58, no.69 integer: 0
Line 58, no.70 integer: 3
Line 58, no.71 integer: 2

Line 58, no.72 integer: 2
Line 58, no.73 integer: 0
Line 58, no.74 integer: 2
Line 58, no.75 integer: 1
Line 58, no.76 integer: 0
Line 58, no.77 integer: 0
Line 58, no.78 integer: 0
Line 58, no.79 integer: 0
Line 58, no.80 integer: 0
Line 58, no.81 integer: 1

Line 58, no.82 integer: 3
Line 58, no.83 integer: 0
Line 58, no.84 integer: 3
Line 58, no.85 integer: 3
Line 58, no.86 integer: 2
Line 58, no.87 integer: 2
Line 58, no.88 integer: 2
Line 58, no.89 integer: 2
Line 58, no.90 integer: 0
Line 58, no.91 integer: 1

Line 58, no.92 integer: 0
Line 58, no.93 integer: 0
Line 58, no.94 integer: 1
Line 58, no.95 integer: 3
Line 58, no.96 integer: 0
Line 58, no.97 integer: 0
Line 58, no.98 integer: 0
Line 58, no.99 integer: 1
Line 58, no.100 integer: 1
Line 58, no.101 integer: 3

Line 58, no.102 integer: 3
Line 58, no.103 integer: 0
Line 58, no.104 integer: 3
Line 58, no.105 integer: 3
Line 58, no.106 integer: 1
Line 58, no.107 integer: 3
Line 58, no.108 integer: 3
Line 58, no.109 integer: 0
Line 58, no.110 integer: 3
Line 58, no.111 integer: 0



Line 58, no.112 integer: 256

Line 58, no.113 integer: 0

Line 58, no.114 integer: 1
Line 58, no.115 integer: 1
Line 58, no.116 integer: 1
Line 58, no.117 integer: 1
Line 58, no.118 integer: 1
Line 58, no.119 integer: 1
Line 58, no.120 integer: 1
Line 58, no.121 integer: 1
Line 58, no.122 integer: 1
Line 58, no.123 integer: 2

Line 58, no.124 integer: 1
Line 58, no.125 integer: 1
Line 58, no.126 integer: 3
Line 58, no.127 integer: 1
Line 58, no.128 integer: 1
Line 58, no.129 integer: 1
Line 58, no.130 integer: 1
Line 58, no.131 integer: 1
Line 58, no.132 integer: 1
Line 58, no.133 integer: 1

Line 58, no.134 integer: 1
Line 58, no.135 integer: 1
Line 58, no.136 integer: 1
Line 58, no.137 integer: 1
Line 58, no.138 integer: 1
Line 58, no.139 integer: 1
Line 58, no.140 integer: 1
Line 58, no.141 integer: 1
Line 58, no.142 integer: 1
Line 58, no.143 integer: 1

Line 58, no.144 integer: 1
Line 58, no.145 integer: 1
Line 58, no.146 integer: 1
Line 58, no.147 integer: 1
Line 58, no.148 integer: 1
Line 58, no.149 integer: 1
Line 58, no.150 integer: 1
Line 58, no.151 integer: 1
Line 58, no.152 integer: 1
Line 58, no.153 integer: 1

Line 58, no.154 integer: 1
Line 58, no.155 integer: 4
Line 58, no.156 integer: 5
Line 58, no.157 integer: 1
Line 58, no.158 integer: 6
Line 58, no.159 integer: 7
Line 58, no.160 integer: 8
Line 58, no.161 integer: 9
Line 58, no.162 integer: 10
Line 58, no.163 integer: 10

Line 58, no.164 integer: 10
Line 58, no.165 integer: 10
Line 58, no.166 integer: 10
Line 58, no.167 integer: 10
Line 58, no.168 integer: 10
Line 58, no.169 integer: 11
Line 58, no.170 integer: 11
Line 58, no.171 integer: 1
Line 58, no.172 integer: 1
Line 58, no.173 integer: 1

Line 58, no.174 integer: 1
Line 58, no.175 integer: 1
Line 58, no.176 integer: 1
Line 58, no.177 integer: 1
Line 58, no.178 integer: 12
Line 58, no.179 integer: 12
Line 58, no.180 integer: 12
Line 58, no.181 integer: 12
Line 58, no.182 integer: 13
Line 58, no.183 integer: 14

Line 58, no.184 integer: 15
Line 58, no.185 integer: 15
Line 58, no.186 integer: 15
Line 58, no.187 integer: 15
Line 58, no.188 integer: 15
Line 58, no.189 integer: 16
Line 58, no.190 integer: 15
Line 58, no.191 integer: 15
Line 58, no.192 integer: 15
Line 58, no.193 integer: 17

Line 58, no.194 integer: 15
Line 58, no.195 integer: 15
Line 58, no.196 integer: 15
Line 58, no.197 integer: 15
Line 58, no.198 integer: 18
Line 58, no.199 integer: 15
Line 58, no.200 integer: 15
Line 58, no.201 integer: 19
Line 58, no.202 integer: 15
Line 58, no.203 integer: 15

Line 58, no.204 integer: 1
Line 58, no.205 integer: 20
Line 58, no.206 integer: 1
Line 58, no.207 integer: 1
Line 58, no.208 integer: 15
Line 58, no.209 integer: 1
Line 58, no.210 integer: 12
Line 58, no.211 integer: 12
Line 58, no.212 integer: 12
Line 58, no.213 integer: 12


Line 58, no.214 integer: 21
Line 58, no.215 integer: 22
Line 58, no.216 integer: 15
Line 58, no.217 integer: 15
Line 58, no.218 integer: 15
Line 58, no.219 integer: 15
Line 58, no.220 integer: 15
Line 58, no.221 integer: 23
Line 58, no.222 integer: 15
Line 58, no.223 integer: 15

Line 58, no.224 integer: 15
Line 58, no.225 integer: 24
Line 58, no.226 integer: 15
Line 58, no.227 integer: 15
Line 58, no.228 integer: 15
Line 58, no.229 integer: 15
Line 58, no.230 integer: 25
Line 58, no.231 integer: 15
Line 58, no.232 integer: 15
Line 58, no.233 integer: 26

Line 58, no.234 integer: 15
Line 58, no.235 integer: 15
Line 58, no.236 integer: 1
Line 58, no.237 integer: 1
Line 58, no.238 integer: 1
Line 58, no.239 integer: 1
Line 58, no.240 integer: 1
Line 58, no.241 integer: 1
Line 58, no.242 integer: 1
Line 58, no.243 integer: 1

Line 58, no.244 integer: 1
Line 58, no.245 integer: 1
Line 58, no.246 integer: 1
Line 58, no.247 integer: 1
Line 58, no.248 integer: 1
Line 58, no.249 integer: 1
Line 58, no.250 integer: 1
Line 58, no.251 integer: 1
Line 58, no.252 integer: 1
Line 58, no.253 integer: 1

Line 58, no.254 integer: 1
Line 58, no.255 integer: 1
Line 58, no.256 integer: 1
Line 58, no.257 integer: 1
Line 58, no.258 integer: 1
Line 58, no.259 integer: 1
Line 58, no.260 integer: 1
Line 58, no.261 integer: 1
Line 58, no.262 integer: 1
Line 58, no.263 integer: 1

Line 58, no.264 integer: 1
Line 58, no.265 integer: 1
Line 58, no.266 integer: 1
Line 58, no.267 integer: 1
Line 58, no.268 integer: 1
Line 58, no.269 integer: 1
Line 58, no.270 integer: 1
Line 58, no.271 integer: 1
Line 58, no.272 integer: 1
Line 58, no.273 integer: 1

Line 58, no.274 integer: 1
Line 58, no.275 integer: 1
Line 58, no.276 integer: 1
Line 58, no.277 integer: 1
Line 58, no.278 integer: 1
Line 58, no.279 integer: 1
Line 58, no.280 integer: 1
Line 58, no.281 integer: 1
Line 58, no.282 integer: 1
Line 58, no.283 integer: 1

Line 58, no.284 integer: 1
Line 58, no.285 integer: 1
Line 58, no.286 integer: 1
Line 58, no.287 integer: 1
Line 58, no.288 integer: 1
Line 58, no.289 integer: 1
Line 58, no.290 integer: 1
Line 58, no.291 integer: 1
Line 58, no.292 integer: 1
Line 58, no.293 integer: 1

Line 58, no.294 integer: 1
Line 58, no.295 integer: 1
Line 58, no.296 integer: 1
Line 58, no.297 integer: 1
Line 58, no.298 integer: 1
Line 58, no.299 integer: 1
Line 58, no.300 integer: 1
Line 58, no.301 integer: 1
Line 58, no.302 integer: 1
Line 58, no.303 integer: 1

Line 58, no.304 integer: 1
Line 58, no.305 integer: 1
Line 58, no.306 integer: 1
Line 58, no.307 integer: 1
Line 58, no.308 integer: 1
Line 58, no.309 integer: 1
Line 58, no.310 integer: 1
Line 58, no.311 integer: 1
Line 58, no.312 integer: 1
Line 58, no.313 integer: 1


Line 58, no.314 integer: 1
Line 58, no.315 integer: 1
Line 58, no.316 integer: 1
Line 58, no.317 integer: 1
Line 58, no.318 integer: 1
Line 58, no.319 integer: 1
Line 58, no.320 integer: 1
Line 58, no.321 integer: 1
Line 58, no.322 integer: 1
Line 58, no.323 integer: 1

Line 58, no.324 integer: 1
Line 58, no.325 integer: 1
Line 58, no.326 integer: 1
Line 58, no.327 integer: 1
Line 58, no.328 integer: 1
Line 58, no.329 integer: 1
Line 58, no.330 integer: 1
Line 58, no.331 integer: 1
Line 58, no.332 integer: 1
Line 58, no.333 integer: 1

Line 58, no.334 integer: 1
Line 58, no.335 integer: 1
Line 58, no.336 integer: 1
Line 58, no.337 integer: 1
Line 58, no.338 integer: 1
Line 58, no.339 integer: 1
Line 58, no.340 integer: 1
Line 58, no.341 integer: 1
Line 58, no.342 integer: 1
Line 58, no.343 integer: 1

Line 58, no.344 integer: 1
Line 58, no.345 integer: 1
Line 58, no.346 integer: 1
Line 58, no.347 integer: 1
Line 58, no.348 integer: 1
Line 58, no.349 integer: 1
Line 58, no.350 integer: 1
Line 58, no.351 integer: 1
Line 58, no.352 integer: 1
Line 58, no.353 integer: 1

Line 58, no.354 integer: 1
Line 58, no.355 integer: 1
Line 58, no.356 integer: 1
Line 58, no.357 integer: 1
Line 58, no.358 integer: 1
Line 58, no.359 integer: 1
Line 58, no.360 integer: 1
Line 58, no.361 integer: 1
Line 58, no.362 integer: 1
Line 58, no.363 integer: 1

Line 58, no.364 integer: 1
Line 58, no.365 integer: 1
Line 58, no.366 integer: 1
Line 58, no.367 integer: 1
Line 58, no.368 integer: 1



Line 58, no.369 integer: 27

Line 58, no.370 integer: 0

Line 58, no.371 integer: 1
Line 58, no.372 integer: 2
Line 58, no.373 integer: 1
Line 58, no.374 integer: 1
Line 58, no.375 integer: 1
Line 58, no.376 integer: 1
Line 58, no.377 integer: 1
Line 58, no.378 integer: 1
Line 58, no.379 integer: 3
Line 58, no.380 integer: 3

Line 58, no.381 integer: 3
Line 58, no.382 integer: 3
Line 58, no.383 integer: 3
Line 58, no.384 integer: 3
Line 58, no.385 integer: 4
Line 58, no.386 integer: 4
Line 58, no.387 integer: 4
Line 58, no.388 integer: 4
Line 58, no.389 integer: 4
Line 58, no.390 integer: 4

Line 58, no.391 integer: 3
Line 58, no.392 integer: 3
Line 58, no.393 integer: 4
Line 58, no.394 integer: 4
Line 58, no.395 integer: 4
Line 58, no.396 integer: 4



Line 58, no.397 integer: 71

Line 58, no.398 integer: 0

Line 58, no.399 integer: 0
Line 58, no.400 integer: 0
Line 58, no.401 integer: 118
Line 58, no.402 integer: 231
Line 58, no.403 integer: 231
Line 58, no.404 integer: 18
Line 58, no.405 integer: 26
Line 58, no.406 integer: 28
Line 58, no.407 integer: 46
Line 58, no.408 integer: 97

Line 58, no.409 integer: 15
Line 58, no.410 integer: 0
Line 58, no.411 integer: 0
Line 58, no.412 integer: 55
Line 58, no.413 integer: 0
Line 58, no.414 integer: 51
Line 58, no.415 integer: 22
Line 58, no.416 integer: 68
Line 58, no.417 integer: 231
Line 58, no.418 integer: 98

Line 58, no.419 integer: 20
Line 58, no.420 integer: 0
Line 58, no.421 integer: 90
Line 58, no.422 integer: 91
Line 58, no.423 integer: 27
Line 58, no.424 integer: 0
Line 58, no.425 integer: 64
Line 58, no.426 integer: 67
Line 58, no.427 integer: 78
Line 58, no.428 integer: 0

Line 58, no.429 integer: 78
Line 58, no.430 integer: 74
Line 58, no.431 integer: 93
Line 58, no.432 integer: 111
Line 58, no.433 integer: 231
Line 58, no.434 integer: 94
Line 58, no.435 integer: 85
Line 58, no.436 integer: 128
Line 58, no.437 integer: 0
Line 58, no.438 integer: 145

Line 58, no.439 integer: 93
Line 58, no.440 integer: 126
Line 58, no.441 integer: 231
Line 58, no.442 integer: 54
Line 58, no.443 integer: 0
Line 58, no.444 integer: 0
Line 58, no.445 integer: 163
Line 58, no.446 integer: 166
Line 58, no.447 integer: 0
Line 58, no.448 integer: 175

Line 58, no.449 integer: 81
Line 58, no.450 integer: 127
Line 58, no.451 integer: 190
Line 58, no.452 integer: 130
Line 58, no.453 integer: 0
Line 58, no.454 integer: 0
Line 58, no.455 integer: 138
Line 58, no.456 integer: 0
Line 58, no.457 integer: 0
Line 58, no.458 integer: 231

Line 58, no.459 integer: 214
Line 58, no.460 integer: 218
Line 58, no.461 integer: 222
Line 58, no.462 integer: 103
Line 58, no.463 integer: 90
Line 58, no.464 integer: 226
Line 58, no.465 integer: 87
Line 58, no.466 integer: 73
Line 58, no.467 integer: 72
Line 58, no.468 integer: 45



Line 58, no.469 integer: 71

Line 58, no.470 integer: 0

Line 58, no.471 integer: 60
Line 58, no.472 integer: 1
Line 58, no.473 integer: 60
Line 58, no.474 integer: 60
Line 58, no.475 integer: 60
Line 58, no.476 integer: 60
Line 58, no.477 integer: 60
Line 58, no.478 integer: 60
Line 58, no.479 integer: 8
Line 58, no.480 integer: 61

Line 58, no.481 integer: 60
Line 58, no.482 integer: 8
Line 58, no.483 integer: 9
Line 58, no.484 integer: 62
Line 58, no.485 integer: 63
Line 58, no.486 integer: 60
Line 58, no.487 integer: 9
Line 58, no.488 integer: 60
Line 58, no.489 integer: 60
Line 58, no.490 integer: 60

Line 58, no.491 integer: 60
Line 58, no.492 integer: 64
Line 58, no.493 integer: 60
Line 58, no.494 integer: 61
Line 58, no.495 integer: 60
Line 58, no.496 integer: 65
Line 58, no.497 integer: 62
Line 58, no.498 integer: 62
Line 58, no.499 integer: 66
Line 58, no.500 integer: 63

Line 58, no.501 integer: 60
Line 58, no.502 integer: 60
Line 58, no.503 integer: 60
Line 58, no.504 integer: 60
Line 58, no.505 integer: 60
Line 58, no.506 integer: 60
Line 58, no.507 integer: 60
Line 58, no.508 integer: 64
Line 58, no.509 integer: 67
Line 58, no.510 integer: 61

Line 58, no.511 integer: 62
Line 58, no.512 integer: 62
Line 58, no.513 integer: 60
Line 58, no.514 integer: 34
Line 58, no.515 integer: 68
Line 58, no.516 integer: 69
Line 58, no.517 integer: 60
Line 58, no.518 integer: 40
Line 58, no.519 integer: 40
Line 58, no.520 integer: 68

Line 58, no.521 integer: 69
Line 58, no.522 integer: 60
Line 58, no.523 integer: 60
Line 58, no.524 integer: 60
Line 58, no.525 integer: 48
Line 58, no.526 integer: 50
Line 58, no.527 integer: 60
Line 58, no.528 integer: 70
Line 58, no.529 integer: 70
Line 58, no.530 integer: 0

Line 58, no.531 integer: 60
Line 58, no.532 integer: 60
Line 58, no.533 integer: 60
Line 58, no.534 integer: 60
Line 58, no.535 integer: 60
Line 58, no.536 integer: 60
Line 58, no.537 integer: 60
Line 58, no.538 integer: 60
Line 58, no.539 integer: 60
Line 58, no.540 integer: 60



Line 58, no.541 integer: 258

Line 58, no.542 integer: 0

Line 58, no.543 integer: 4
Line 58, no.544 integer: 5
Line 58, no.545 integer: 4
Line 58, no.546 integer: 4
Line 58, no.547 integer: 6
Line 58, no.548 integer: 6
Line 58, no.549 integer: 4
Line 58, no.550 integer: 7
Line 58, no.551 integer: 8
Line 58, no.552 integer: 9

Line 58, no.553 integer: 9
Line 58, no.554 integer: 10
Line 58, no.555 integer: 10
Line 58, no.556 integer: 10
Line 58, no.557 integer: 10
Line 58, no.558 integer: 10
Line 58, no.559 integer: 10
Line 58, no.560 integer: 10
Line 58, no.561 integer: 10
Line 58, no.562 integer: 11

Line 58, no.563 integer: 10
Line 58, no.564 integer: 10
Line 58, no.565 integer: 10
Line 58, no.566 integer: 10
Line 58, no.567 integer: 10
Line 58, no.568 integer: 10
Line 58, no.569 integer: 12
Line 58, no.570 integer: 13
Line 58, no.571 integer: 13
Line 58, no.572 integer: 14

Line 58, no.573 integer: 17
Line 58, no.574 integer: 17
Line 58, no.575 integer: 26
Line 58, no.576 integer: 15
Line 58, no.577 integer: 16
Line 58, no.578 integer: 36
Line 58, no.579 integer: 17
Line 58, no.580 integer: 17
Line 58, no.581 integer: 13
Line 58, no.582 integer: 26

Line 58, no.583 integer: 18
Line 58, no.584 integer: 19
Line 58, no.585 integer: 37
Line 58, no.586 integer: 20
Line 58, no.587 integer: 39
Line 58, no.588 integer: 21
Line 58, no.589 integer: 22
Line 58, no.590 integer: 59
Line 58, no.591 integer: 18
Line 58, no.592 integer: 19

Line 58, no.593 integer: 23
Line 58, no.594 integer: 39
Line 58, no.595 integer: 21
Line 58, no.596 integer: 22
Line 58, no.597 integer: 13
Line 58, no.598 integer: 13
Line 58, no.599 integer: 28
Line 58, no.600 integer: 28
Line 58, no.601 integer: 29
Line 58, no.602 integer: 31

Line 58, no.603 integer: 31
Line 58, no.604 integer: 31
Line 58, no.605 integer: 44
Line 58, no.606 integer: 44
Line 58, no.607 integer: 60
Line 58, no.608 integer: 28
Line 58, no.609 integer: 28
Line 58, no.610 integer: 29
Line 58, no.611 integer: 28
Line 58, no.612 integer: 28

Line 58, no.613 integer: 29
Line 58, no.614 integer: 60
Line 58, no.615 integer: 32
Line 58, no.616 integer: 32
Line 58, no.617 integer: 51
Line 58, no.618 integer: 50
Line 58, no.619 integer: 33
Line 58, no.620 integer: 34
Line 58, no.621 integer: 34
Line 58, no.622 integer: 42

Line 58, no.623 integer: 42
Line 58, no.624 integer: 29
Line 58, no.625 integer: 33
Line 58, no.626 integer: 34
Line 58, no.627 integer: 34
Line 58, no.628 integer: 43
Line 58, no.629 integer: 31
Line 58, no.630 integer: 31
Line 58, no.631 integer: 31
Line 58, no.632 integer: 48

Line 58, no.633 integer: 18
Line 58, no.634 integer: 19
Line 58, no.635 integer: 40
Line 58, no.636 integer: 19
Line 58, no.637 integer: 28
Line 58, no.638 integer: 28
Line 58, no.639 integer: 29
Line 58, no.640 integer: 47
Line 58, no.641 integer: 18
Line 58, no.642 integer: 19


Line 58, no.643 integer: 19
Line 58, no.644 integer: 44
Line 58, no.645 integer: 44
Line 58, no.646 integer: 34
Line 58, no.647 integer: 47
Line 58, no.648 integer: 38
Line 58, no.649 integer: 19
Line 58, no.650 integer: 35
Line 58, no.651 integer: 19
Line 58, no.652 integer: 35

Line 58, no.653 integer: 25
Line 58, no.654 integer: 45
Line 58, no.655 integer: 35
Line 58, no.656 integer: 35
Line 58, no.657 integer: 19
Line 58, no.658 integer: 19
Line 58, no.659 integer: 25
Line 58, no.660 integer: 60
Line 58, no.661 integer: 45
Line 58, no.662 integer: 34

Line 58, no.663 integer: 34
Line 58, no.664 integer: 34
Line 58, no.665 integer: 60
Line 58, no.666 integer: 60
Line 58, no.667 integer: 19
Line 58, no.668 integer: 60
Line 58, no.669 integer: 19
Line 58, no.670 integer: 28
Line 58, no.671 integer: 28
Line 58, no.672 integer: 29

Line 58, no.673 integer: 60
Line 58, no.674 integer: 60
Line 58, no.675 integer: 19
Line 58, no.676 integer: 19
Line 58, no.677 integer: 46
Line 58, no.678 integer: 53
Line 58, no.679 integer: 54
Line 58, no.680 integer: 54
Line 58, no.681 integer: 54
Line 58, no.682 integer: 54

Line 58, no.683 integer: 54
Line 58, no.684 integer: 60
Line 58, no.685 integer: 60
Line 58, no.686 integer: 36
Line 58, no.687 integer: 47
Line 58, no.688 integer: 21
Line 58, no.689 integer: 57
Line 58, no.690 integer: 57
Line 58, no.691 integer: 54
Line 58, no.692 integer: 60

Line 58, no.693 integer: 37
Line 58, no.694 integer: 47
Line 58, no.695 integer: 21
Line 58, no.696 integer: 49
Line 58, no.697 integer: 49
Line 58, no.698 integer: 49
Line 58, no.699 integer: 49
Line 58, no.700 integer: 49
Line 58, no.701 integer: 49
Line 58, no.702 integer: 60

Line 58, no.703 integer: 60
Line 58, no.704 integer: 60
Line 58, no.705 integer: 60
Line 58, no.706 integer: 60
Line 58, no.707 integer: 25
Line 58, no.708 integer: 49
Line 58, no.709 integer: 49
Line 58, no.710 integer: 52
Line 58, no.711 integer: 52
Line 58, no.712 integer: 60

Line 58, no.713 integer: 60
Line 58, no.714 integer: 53
Line 58, no.715 integer: 54
Line 58, no.716 integer: 54
Line 58, no.717 integer: 55
Line 58, no.718 integer: 55
Line 58, no.719 integer: 55
Line 58, no.720 integer: 55
Line 58, no.721 integer: 55
Line 58, no.722 integer: 55

Line 58, no.723 integer: 60
Line 58, no.724 integer: 60
Line 58, no.725 integer: 60
Line 58, no.726 integer: 60
Line 58, no.727 integer: 60
Line 58, no.728 integer: 60
Line 58, no.729 integer: 55
Line 58, no.730 integer: 55
Line 58, no.731 integer: 56
Line 58, no.732 integer: 60

Line 58, no.733 integer: 19
Line 58, no.734 integer: 60
Line 58, no.735 integer: 60
Line 58, no.736 integer: 60
Line 58, no.737 integer: 60
Line 58, no.738 integer: 60
Line 58, no.739 integer: 56
Line 58, no.740 integer: 19
Line 58, no.741 integer: 57
Line 58, no.742 integer: 57


Line 58, no.743 integer: 54
Line 58, no.744 integer: 60
Line 58, no.745 integer: 60
Line 58, no.746 integer: 60
Line 58, no.747 integer: 60
Line 58, no.748 integer: 60
Line 58, no.749 integer: 60
Line 58, no.750 integer: 60
Line 58, no.751 integer: 58
Line 58, no.752 integer: 60

Line 58, no.753 integer: 60
Line 58, no.754 integer: 60
Line 58, no.755 integer: 60
Line 58, no.756 integer: 60
Line 58, no.757 integer: 60
Line 58, no.758 integer: 58
Line 58, no.759 integer: 24
Line 58, no.760 integer: 24
Line 58, no.761 integer: 27
Line 58, no.762 integer: 27

Line 58, no.763 integer: 27
Line 58, no.764 integer: 27
Line 58, no.765 integer: 30
Line 58, no.766 integer: 60
Line 58, no.767 integer: 30
Line 58, no.768 integer: 30
Line 58, no.769 integer: 41
Line 58, no.770 integer: 41
Line 58, no.771 integer: 41
Line 58, no.772 integer: 41

Line 58, no.773 integer: 3
Line 58, no.774 integer: 60
Line 58, no.775 integer: 60
Line 58, no.776 integer: 60
Line 58, no.777 integer: 60
Line 58, no.778 integer: 60
Line 58, no.779 integer: 60
Line 58, no.780 integer: 60
Line 58, no.781 integer: 60
Line 58, no.782 integer: 60

Line 58, no.783 integer: 60
Line 58, no.784 integer: 60
Line 58, no.785 integer: 60
Line 58, no.786 integer: 60
Line 58, no.787 integer: 60
Line 58, no.788 integer: 60
Line 58, no.789 integer: 60
Line 58, no.790 integer: 60
Line 58, no.791 integer: 60
Line 58, no.792 integer: 60

Line 58, no.793 integer: 60
Line 58, no.794 integer: 60
Line 58, no.795 integer: 60
Line 58, no.796 integer: 60
Line 58, no.797 integer: 60
Line 58, no.798 integer: 60
Line 58, no.799 integer: 60



Line 58, no.800 integer: 258

Line 58, no.801 integer: 0

Line 58, no.802 integer: 1
Line 58, no.803 integer: 1
Line 58, no.804 integer: 1
Line 58, no.805 integer: 1
Line 58, no.806 integer: 1
Line 58, no.807 integer: 1
Line 58, no.808 integer: 1
Line 58, no.809 integer: 1
Line 58, no.810 integer: 1
Line 58, no.811 integer: 1

Line 58, no.812 integer: 1
Line 58, no.813 integer: 1
Line 58, no.814 integer: 1
Line 58, no.815 integer: 1
Line 58, no.816 integer: 1
Line 58, no.817 integer: 1
Line 58, no.818 integer: 1
Line 58, no.819 integer: 1
Line 58, no.820 integer: 1
Line 58, no.821 integer: 1

Line 58, no.822 integer: 1
Line 58, no.823 integer: 1
Line 58, no.824 integer: 1
Line 58, no.825 integer: 1
Line 58, no.826 integer: 1
Line 58, no.827 integer: 1
Line 58, no.828 integer: 6
Line 58, no.829 integer: 6
Line 58, no.830 integer: 6
Line 58, no.831 integer: 7

Line 58, no.832 integer: 17
Line 58, no.833 integer: 17
Line 58, no.834 integer: 11
Line 58, no.835 integer: 7
Line 58, no.836 integer: 8
Line 58, no.837 integer: 21
Line 58, no.838 integer: 8
Line 58, no.839 integer: 8
Line 58, no.840 integer: 8
Line 58, no.841 integer: 11

Line 58, no.842 integer: 8
Line 58, no.843 integer: 8
Line 58, no.844 integer: 21
Line 58, no.845 integer: 8
Line 58, no.846 integer: 25
Line 58, no.847 integer: 8
Line 58, no.848 integer: 8
Line 58, no.849 integer: 70
Line 58, no.850 integer: 8
Line 58, no.851 integer: 8

Line 58, no.852 integer: 8
Line 58, no.853 integer: 25
Line 58, no.854 integer: 8
Line 58, no.855 integer: 8
Line 58, no.856 integer: 9
Line 58, no.857 integer: 9
Line 58, no.858 integer: 14
Line 58, no.859 integer: 14
Line 58, no.860 integer: 14
Line 58, no.861 integer: 16

Line 58, no.862 integer: 16
Line 58, no.863 integer: 16
Line 58, no.864 integer: 44
Line 58, no.865 integer: 44
Line 58, no.866 integer: 9
Line 58, no.867 integer: 27
Line 58, no.868 integer: 27
Line 58, no.869 integer: 27
Line 58, no.870 integer: 28
Line 58, no.871 integer: 28

Line 58, no.872 integer: 28
Line 58, no.873 integer: 9
Line 58, no.874 integer: 18
Line 58, no.875 integer: 18
Line 58, no.876 integer: 69
Line 58, no.877 integer: 68
Line 58, no.878 integer: 18
Line 58, no.879 integer: 18
Line 58, no.880 integer: 18
Line 58, no.881 integer: 29

Line 58, no.882 integer: 29
Line 58, no.883 integer: 29
Line 58, no.884 integer: 32
Line 58, no.885 integer: 32
Line 58, no.886 integer: 32
Line 58, no.887 integer: 29
Line 58, no.888 integer: 31
Line 58, no.889 integer: 31
Line 58, no.890 integer: 31
Line 58, no.891 integer: 67

Line 58, no.892 integer: 31
Line 58, no.893 integer: 31
Line 58, no.894 integer: 65
Line 58, no.895 integer: 31
Line 58, no.896 integer: 41
Line 58, no.897 integer: 41
Line 58, no.898 integer: 41
Line 58, no.899 integer: 51
Line 58, no.900 integer: 31
Line 58, no.901 integer: 31


Line 58, no.902 integer: 31
Line 58, no.903 integer: 33
Line 58, no.904 integer: 33
Line 58, no.905 integer: 33
Line 58, no.906 integer: 51
Line 58, no.907 integer: 64
Line 58, no.908 integer: 33
Line 58, no.909 integer: 37
Line 58, no.910 integer: 33
Line 58, no.911 integer: 36

Line 58, no.912 integer: 24
Line 58, no.913 integer: 33
Line 58, no.914 integer: 23
Line 58, no.915 integer: 20
Line 58, no.916 integer: 33
Line 58, no.917 integer: 33
Line 58, no.918 integer: 10
Line 58, no.919 integer: 3
Line 58, no.920 integer: 33
Line 58, no.921 integer: 34

Line 58, no.922 integer: 34
Line 58, no.923 integer: 34
Line 58, no.924 integer: 0
Line 58, no.925 integer: 0
Line 58, no.926 integer: 34
Line 58, no.927 integer: 0
Line 58, no.928 integer: 34
Line 58, no.929 integer: 42
Line 58, no.930 integer: 42
Line 58, no.931 integer: 42

Line 58, no.932 integer: 0
Line 58, no.933 integer: 0
Line 58, no.934 integer: 34
Line 58, no.935 integer: 34
Line 58, no.936 integer: 38
Line 58, no.937 integer: 52
Line 58, no.938 integer: 52
Line 58, no.939 integer: 52
Line 58, no.940 integer: 54
Line 58, no.941 integer: 54

Line 58, no.942 integer: 54
Line 58, no.943 integer: 0
Line 58, no.944 integer: 0
Line 58, no.945 integer: 38
Line 58, no.946 integer: 38
Line 58, no.947 integer: 38
Line 58, no.948 integer: 57
Line 58, no.949 integer: 57
Line 58, no.950 integer: 57
Line 58, no.951 integer: 0

Line 58, no.952 integer: 38
Line 58, no.953 integer: 38
Line 58, no.954 integer: 38
Line 58, no.955 integer: 40
Line 58, no.956 integer: 40
Line 58, no.957 integer: 40
Line 58, no.958 integer: 40
Line 58, no.959 integer: 40
Line 58, no.960 integer: 40
Line 58, no.961 integer: 0

Line 58, no.962 integer: 0
Line 58, no.963 integer: 0
Line 58, no.964 integer: 0
Line 58, no.965 integer: 0
Line 58, no.966 integer: 40
Line 58, no.967 integer: 40
Line 58, no.968 integer: 40
Line 58, no.969 integer: 47
Line 58, no.970 integer: 47
Line 58, no.971 integer: 0

Line 58, no.972 integer: 0
Line 58, no.973 integer: 47
Line 58, no.974 integer: 47
Line 58, no.975 integer: 47
Line 58, no.976 integer: 48
Line 58, no.977 integer: 48
Line 58, no.978 integer: 48
Line 58, no.979 integer: 48
Line 58, no.980 integer: 48
Line 58, no.981 integer: 48

Line 58, no.982 integer: 0
Line 58, no.983 integer: 0
Line 58, no.984 integer: 0
Line 58, no.985 integer: 0
Line 58, no.986 integer: 0
Line 58, no.987 integer: 0
Line 58, no.988 integer: 48
Line 58, no.989 integer: 48
Line 58, no.990 integer: 50
Line 58, no.991 integer: 0

Line 58, no.992 integer: 50
Line 58, no.993 integer: 0
Line 58, no.994 integer: 0
Line 58, no.995 integer: 0
Line 58, no.996 integer: 0
Line 58, no.997 integer: 0
Line 58, no.998 integer: 50
Line 58, no.999 integer: 50
Line 58, no.1000 integer: 53
Line 58, no.1001 integer: 53


Line 58, no.1002 integer: 53
Line 58, no.1003 integer: 0
Line 58, no.1004 integer: 0
Line 58, no.1005 integer: 0
Line 58, no.1006 integer: 0
Line 58, no.1007 integer: 0
Line 58, no.1008 integer: 0
Line 58, no.1009 integer: 0
Line 58, no.1010 integer: 53
Line 58, no.1011 integer: 0

Line 58, no.1012 integer: 0
Line 58, no.1013 integer: 0
Line 58, no.1014 integer: 0
Line 58, no.1015 integer: 0
Line 58, no.1016 integer: 0
Line 58, no.1017 integer: 53
Line 58, no.1018 integer: 61
Line 58, no.1019 integer: 61
Line 58, no.1020 integer: 62
Line 58, no.1021 integer: 62

Line 58, no.1022 integer: 62
Line 58, no.1023 integer: 62
Line 58, no.1024 integer: 63
Line 58, no.1025 integer: 0
Line 58, no.1026 integer: 63
Line 58, no.1027 integer: 63
Line 58, no.1028 integer: 66
Line 58, no.1029 integer: 66
Line 58, no.1030 integer: 66
Line 58, no.1031 integer: 66

Line 58, no.1032 integer: 60
Line 58, no.1033 integer: 60
Line 58, no.1034 integer: 60
Line 58, no.1035 integer: 60
Line 58, no.1036 integer: 60
Line 58, no.1037 integer: 60
Line 58, no.1038 integer: 60
Line 58, no.1039 integer: 60
Line 58, no.1040 integer: 60
Line 58, no.1041 integer: 60

Line 58, no.1042 integer: 60
Line 58, no.1043 integer: 60
Line 58, no.1044 integer: 60
Line 58, no.1045 integer: 60
Line 58, no.1046 integer: 60
Line 58, no.1047 integer: 60
Line 58, no.1048 integer: 60
Line 58, no.1049 integer: 60
Line 58, no.1050 integer: 60
Line 58, no.1051 integer: 60

Line 58, no.1052 integer: 60
Line 58, no.1053 integer: 60
Line 58, no.1054 integer: 60
Line 58, no.1055 integer: 60
Line 58, no.1056 integer: 60
Line 58, no.1057 integer: 60
Line 58, no.1058 integer: 60




Line 58, no.1059 integer: 6

Line 58, no.1060 integer: 0

Line 58, no.1061 integer: 1
Line 58, no.1062 integer: 0
Line 58, no.1063 integer: 0
Line 58, no.1064 integer: 0
Line 58, no.1065 integer: 0






Line 58, no.1066 integer: 0





Line 60, no.1067 integer: 0



Line 60, no.1068 integer: 1

Line 60, no.1069 integer: 2



Line 60, no.1070 integer: 0
Line 60, no.1071 integer: 0

Line 60, no.1 float: +31.415926E-1F







Line 62, no.1072 integer: 554

Line 62, no.1073 integer: 555


Line 62, no.1074 integer: 0














































































Line 68, no.1075 integer: 16384


Line 68, no.1076 integer: 8192







Line 70, no.1077 integer: 1
Line 70, no.1078 integer: 0










Line 72, no.1079 integer: 0











Line 72, no.1080 integer: 0

Line 72, no.1081 integer: 1
Line 72, no.1082 integer: 0







Line 72, no.1083 integer: 0















Line 75, no.1084 integer: 25












Line 77, no.1085 integer: 1





























Line 80, no.1086 integer: 1







Line 80, no.1087 integer: 1


















Line 80, no.1088 integer: 39



Line 80, no.1089 integer: 775


Line 80, no.1090 integer: 1























Line 82, no.1091 integer: 61






Line 82, no.1092 integer: 231




Line 82, no.1093 integer: 0












Line 82, no.1094 integer: 0











Line 82, no.1095 integer: 0







Line 82, no.1096 integer: 1



Line 82, no.1097 integer: 41



Line 82, no.1098 integer: 2


Line 82, no.1099 integer: 42






Line 82, no.1100 integer: 3


Line 82, no.1101 integer: 46






Line 82, no.1102 integer: 4


Line 82, no.1103 integer: 50



Line 82, no.1104 integer: 5


Line 82, no.1105 integer: 52



Line 82, no.1106 integer: 874







Line 82, no.1107 integer: 1
















































Line 103, no.1108 integer: 0


























































Line 117, no.1109 integer: 1




Line 117, no.1110 integer: 0


Line 117, no.1111 integer: 1
















Line 121, no.1112 integer: 1


Line 121, no.1113 integer: 0





Line 123, no.1114 integer: 0





Line 123, no.1115 integer: 1


Line 123, no.1116 integer: 0











Line 123, no.1117 integer: 2


Line 123, no.1118 integer: 0

Line 123, no.1119 integer: 8


Line 123, no.1120 integer: 2





Line 123, no.1121 integer: 2













Line 123, no.1122 integer: 1














Line 123, no.1123 integer: 0





















Line 123, no.1124 integer: 1






Line 123, no.1125 integer: 2





Line 123, no.1126 integer: 1


Line 123, no.1127 integer: 0
















Line 123, no.1128 integer: 1









Line 123, no.1129 integer: 61















Line 127, no.1130 integer: 1









Line 127, no.1131 integer: 61




Line 127, no.1132 integer: 60


Line 127, no.1133 integer: 0














Line 127, no.1134 integer: 2



Line 127, no.1135 integer: 2


Line 127, no.1136 integer: 2












Line 127, no.1137 integer: 2


































Line 130, no.1138 integer: 0




















Line 138, no.1139 integer: 0



















Line 138, no.1140 integer: 0















































Line 153, no.1141 integer: 1























Line 160, no.1142 integer: 2




Line 160, no.1143 integer: 1















Line 163, no.1144 integer: 0

















Line 166, no.1145 integer: 1




Line 169, no.1146 integer: 1

Line 169, no.1147 integer: 0



Line 169, no.1148 integer: 0
Line 169, no.1149 integer: 0











Line 172, no.1150 integer: 0



Line 175, no.1151 integer: 0

Line 175, no.1152 integer: 1


Line 175, no.1153 integer: 0


Line 175, no.1154 integer: 1































Line 180, no.1155 integer: 1











Line 183, no.1156 integer: 0





Line 183, no.1157 integer: 1












Line 188, no.1158 integer: 1







Line 188, no.1159 integer: 0



Line 188, no.1160 integer: 0




Line 188, no.1161 integer: 1



Line 188, no.1162 integer: 8











Line 188, no.1163 integer: 0










Line 193, no.1164 integer: 2

Line 193, no.1165 integer: -2

Line 193, no.1166 integer: -1








Line 193, no.1167 integer: 2


Line 193, no.1168 integer: 0



Line 193, no.1169 integer: 0

Line 193, no.1170 integer: 1

Line 193, no.1171 integer: 0
























Line 206, no.1172 integer: 2





Line 206, no.1173 integer: 0



Line 206, no.1174 integer: +1







Line 208, no.1175 integer: 1






Line 208, no.1176 integer: 2





















Line 208, no.1177 integer: 0



Line 208, no.1178 integer: 0





































































Line 228, no.1179 integer: 1



Line 228, no.1180 integer: 0

Line 228, no.1181 integer: 0


Line 228, no.1182 integer: 0

Line 228, no.1183 integer: 0












Line 230, no.1184 integer: 0





















Line 231, no.1185 integer: 0










Line 233, no.1186 integer: 0









Line 233, no.1187 integer: 0

































Line 239, no.1188 integer: 0



Line 239, no.1189 integer: 52



---
1189 integer(s), 1 float(s) find.

```

## 实验心得

通过本次实验，我实现了一个比较 naive 的 C 语言数值类型提取器，仍然存有一些可以改进的地方：

1. 默认用户输入合法，没有考虑非法情况。例如，对于输入 `08` 来说，以 0 开头的数值类型应当代表的是八进制数，而后面却跟了一个 `8`，应当有一个错误提示。然而，事实上，我的程序会把它当成两个十进制数 `0` 和 `8` 来考虑。
2. 没有考虑表达式中正负号和加减号的区别。例如，对于输入 `1+1` 来说，我的程序会提取出 `1` 和 `+1` 两个数，而事实上正号是单目运算符而加号是双目运算符，两者并不能完全等价，需要基于语法分析树进行区分。

希望日后的学习能够进一步的解决上述问题。

[成绩]: data:image/webp;base64,UklGRvAKAABXRUJQVlA4IOQKAACwXQCdASp7CD8AP73a524+M7EqIpDJk8A3iWdu/C45q+stXcVX8pf67uE8Ba/A3N/Od+u6xvFQy+V4t5aeQhvMp398hPpLdmX2HdIvfJrLKqv7IPJKFS75w5FVX9kHklCpd84ciqr+yDyShUu+cORVV/ZB5JQqXfOHIqq/sg8koVLvnDkVVf2QeR9ykT9h7lVyMeLbhJUgirEuKFaDrBKaWOxhHk0+3STNyHLquDNya0JqL5jyVjoQeDB9V/6gawQUsWX6DUz9sZnTV0XouVdwO0D8uAYEqi4ELyP8RjeK35x2WVUtASZ2eBNB0ET1g/6mXjUOVNct/Pt5tlrn/Cn6FsN0MoiqqmB6+1cSkHDrjjKnssVn3dI68P4xoOajt3xk41+C2h//TTe+TWNm3/U2artWvJKFS75w5EplJa66X1GJnYKARu1kb9bujtbqKqnkkzoijO7IPHMmVS9ko+v7IOclzzVQaQvDjU4ciUyb2YdTaQbQdV03eTaAFfjd/42vzkWuJuqupAbEJn4uHYyMn7c2ojbx17ZARqf3BNuDyRv7sKJ7WsICkwxs8OZOxGLNLyAjSnakvOFLRNia9Wn6QKf6d2h5CQEo3DRJtiOXYC8ORVV+b6nePyVJTBxkNFQpL+J8KCyaqmdFiLsUZ3RXgpDzl3oSWeGSpALWzvAajw7rTThWiWZ9Oi2ChwIDqUIoUzO81CmMKaamssl2LZibUyUXsbywVM5HvJKE/QCVCVOmAHspML96hFVX9kHkkiLy7CD/t0CL2Cf73J/ZsBMKhSQj31wGRmxGwDMIiKzjSrSkDb5QOi7mTPEMnQsx+WcdFLP9sszSfBM9cJjxyKquUEUcGDjurRwBmRFfYNSKquVAm84Z6c/b8xQr6/XE6QAq+kJRei77EuB/G54CG8WHprScwxq98mss/o5dc75w5FVbd0EBv7IPKAHt3yayyrFPZB5JQqXfOHIqq/sg8koVL1h3sLvnDkVVf2QerPZB5JQqXrBUAAD9ROCdD2T18FFH2lrUas4XmWyYWK/W7Pg+AAAAA2j4V2FIVUqssQ6ZyrdMtC7RaUTbRCexI9FSeIMNrsysckAhhkgsRa++TvPzn6gtoF5Fk5gARFyKfzS25ZEmfO1ugpgbt9oDirYP6hc3IrUHRrOZl8c8BXr3SCXosP0fILaZrsh4Ous07a6siLszRtepUNM55UwX6YiFenOaw9Y37AAqzN18uFgJ3EyEmc9dvIS5swKldP+P4R2KL9oT7vcjlE4Ikj6tWCs+Lch6gUHJ5+DDRYLmv/M2Z2DFNZvHZW+QOCpsdeWEUu4sqQc9/WAK+81yQEIc4te6gf3JKdylbd6MHsomRNPGJSr547sfrRnV9PaVAxTeAa8TiGc9iXCxR5s0GmAzn9fyZOfM5G8OVFa5ORJmNyVCoUHqDyEhdXUSTFnKuqlFDsII+c+HPBkhPGfjiVIxfmcjHLGFGIHnSbv7mZwMk+0Ct10aq9t6G05IjSRHn3v9gwnN51lJ9UMPd6wHWjCJI42qbzJMkP2KhVtOMYxYZoc+fyWFKii+vjWfXCS7OcPZEh+BKSKO6Y441Afq2isJmcsjKqsPuESp6eNJeOVy2MW90aQWjkuOQ/GzLRN0S/BQy2soKLzUzSP+bTeH/qdRurKEKR8T3zNy6OGyTZw9jn4oh8+OSVqx+BKSKO6lWwIF78h9uB8lwW4YQe6uYb6/PmawV5/Iy/FHn4akoIQSlrfjWRYQou9ALfw9au8Sa3ddDSHQcnoN1Jy5nnXJYDiFbDvmYeXn8XbyBlRySm+IZ/wYwx8vaZcsu5n6RaUOJVku3BYzPty67k6dQD2pxYQowIYyWkhvyHVk3fzbCWL11ntdNw7mxlQpdt2iUDR2k1CD0zk313yQtOr2DAjxTlEhO2qB2xY71XmI/NlCVOKyZitDOjcYxmNz8NHe95QdRwcNXcDkspmRd1aUhTBipTqAdIOMXYdTW2Y916NEvXhtQcn6YrVgYb4kHwvkURuF1e4hc+AVsJxElM3nVEBxs/gL4wG2SaM8DqPznk65DdmSnrdS1KVS9GyqpCOChmrmfbAYkCe/YK1e9JVv3Q+RjINhBeXGtUpLPZp4ImijeXlA841o7fSLP1I3VIxFRS2ExihvbHYkN+AywEsFC+lQHqmgtEFXH6mhZHa3H5qqoQAhyaWZqIFqlru1lQOJSWi/BVhMN4ivwZhu2DW1u05DzFXFPsI+3RgBL9XB40jmHLK1UtE9GAB4iB6rbgb06grjZd0cxNRrumb4SidytCNErBusltFsEn5IAkzGmfvQhlVEcVO/vl+xvDO+oZgK1PHm0XUYig8WxIjqu1BYHUq0jRtuAKfV4EBA+Oz2jGUNftpVW6kFMZ4U+CDN9of0otW95B3d7A2W9ITDCbyHvc6jLeCtxXEIuZU2foFXNMlUK3kljY37Wr4bOk2ape/VUW2AAJY0I1VT2vXI7fKBjqmoY+bsgZ20LEKga/sCuFP4tPZpnf/IyxRBsKsuOaHLBVLyq0q45djEZZ7JYgRIYwfwviUEqKt6O1sOKjCLWDnWuwfk0DY2rX3rhzRgQ1QI3YTaYUxTgJCsRzWuZ/VPeiiqYX0g0BPI6kkYmDR+l/piCRA5qvskkQUm9cfWONldZDKPT2TYbJ6qGM764CeJ7diqr0nuoteNWI25JXWfT7yO+Vexqf6icdW7J0JIIxxZT7C9ltstmuB436wlG2rFc64YmWVW7QHuvGMsGwjeW8QWUL6i1Fw7qvjA5luUf0fA724y+teEOmbOjQNE+M01yZUHFVsLLgEvJQCVjNdBMffcTv0wrDl+R/9ocWtqlAMQPd+E+bhSL+XCgDSZpmwCBx6vv7WrtsjLLKQL8X4T/GAahcbind4Pv4sWFFswBXrwImYe/D54dUA5d6K6F6tKnpbgqQcgFCr3JYS0TSGj94wgxh4FgDCJEQ1nwQS0EKNsIc5pnNC1GwBcdcjG+aLe46ufCPjpC5Abmn3Kjf4HEEY3Csx+QAgezWq/uZKy2O0XvlgDwMptQXM4G1HvhZUT7X8mWULL4RRB7obU4oG6AGKTtxfd8tr/F++LhJ1gzAR+KfY0RvCfdYJPC3ia3tyvrISM0P69m5yM2f39VOw6G7r6brsViI7Xh0FKV6hL8tEWp/XDx3F+JJdWx5kBLlRiEREFGiVDyF7HpC0OTj4wDsur7uVFaTS/15Q+WTDnNVgX7pnithOmf5cmADn41w2WVUz059/4iSWaHVPjwjTLoqsiLZ0OslrGqxZw/7mmzELF8FBe9VMVPrp1xO5Z/BOb9INlkCMJkQepZvjwcrLsBVt3hD94VsyAeCwHVC5nPE2eiekCjLrVEU0bkwcYIP24ems8uSMEYC/KKX59zcDpRnMS9c2KkyjNtIOtmWbU5wOp80fwolN8OifHJu9Jrpokr/65ICXYmFnvBiWsCFwKsOSQ3FvPENdzzAnxUdWeXEOUb7slb7KkfUx98eR8+/WoEbdIsm3kDHJM0uNyuSov77GRg9hSlGax/VzlaPEKPQhkGn01vVuU4/pIMyQFU3sB7gAgEn324Ki0rj7dGYD/kkmRsasU06LaQhwj+50et6sxlBOg2hwT41tI4qJaKA6EOmYvrAgVkJ5MZYl+qK7Zhwu5JRJx252amfjmCWyMtjpWpp3KhJ16cjRDWgkZbiJPhlKv7VPrmYUAAAAAAAAA
